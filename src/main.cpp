#include <QApplication>
#include <QWidget>
#include <QDir>
#include <QDebug>
#include <QLocale>
#include <QStyleFactory>
#include <QStandardPaths>
#include <QMessageBox>
#include <QDesktopServices>

#include "global.h"
#include "mainwindow.h"
#include "file.h"
#include "filedownloader.h"
#include "lilypond.h"

#define EXITOK 0
#define EXITERROR 1
#define TIMEOUT 2

QCoreApplication* createApplication(int &argc, char *argv[])
{
    if (argc > 2){
        return new QCoreApplication(argc, argv);
    }
    return new QApplication(argc, argv);
}

int main(int argc, char *argv[])
{
    QScopedPointer<QCoreApplication> app(createApplication(argc, argv));

    QCoreApplication::setOrganizationName("tabliato");
    QCoreApplication::setApplicationName("tabliato");
    QCoreApplication::setApplicationVersion("1.3.5");

    APPDIR = QApplication::applicationDirPath();
    APPPATH = QApplication::applicationFilePath();
    LOCAL = QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation);
    TEMPLATE = ":/templates/ressources/templates";
    KEYBOARDS = LOCAL + "/keyboards";
    ICON = ":/icons/ressources/icons";
    HTML = ":/html/ressources/html";
    OUTPUT = LOCAL + "/output";
    SOUNDFONTS = LOCAL + "/soundfonts";

    #ifdef Q_OS_WINDOWS
    MIDIEXT = ".mid";
    AUDIOEXT = ".wav";
    #endif

    #ifdef Q_OS_LINUX
    MIDIEXT = ".midi";
    AUDIOEXT = ".ogg";
    #endif

    QCommandLineParser parser;
    parser.setApplicationDescription("Generate tabulature for accordion from FILE");
    parser.addHelpOption();
    parser.addVersionOption();

    parser.addPositionalArgument("FILE", "Tabliato .dtb file to parse. Can optionnaly be a midi file generated by tabliato");

    QCommandLineOption opt_verbose(QStringList() << "V" << "verbose", "Verbose mode");
    parser.addOption(opt_verbose);

    QCommandLineOption opt_all(QStringList() << "a" << "all", "Export all.");
    parser.addOption(opt_all);

    QCommandLineOption opt_pdf("pdf", "Export pdf.");
    parser.addOption(opt_pdf);

    QCommandLineOption opt_ly("ly", "Export ly.");
    parser.addOption(opt_ly);

    QCommandLineOption opt_png("png", "Export png.");
    parser.addOption(opt_png);

    QCommandLineOption opt_ogg("ogg", "Export ogg.");
    parser.addOption(opt_ogg);

    QCommandLineOption opt_midi("midi", "Export midi.");
    parser.addOption(opt_midi);

    QCommandLineOption opt_sf2("soundfont", "Soundfont to generate audio from midi (implies --ogg)", "file.sf2");
    parser.addOption(opt_sf2);

    QCommandLineOption opt_slow("slow-machine", "Use this option to increase lilypond and timidity timeout");
    parser.addOption(opt_slow);

    QCommandLineOption opt_output(QStringList() << "o" << "output", "Write output in file or folder FILE. File extension is automatically added", "FILE");
    parser.addOption(opt_output);

    parser.process(*app);

    bool verbose = parser.isSet(opt_verbose);
    bool pdf = parser.isSet(opt_pdf);
    bool ly  = parser.isSet(opt_ly);
    bool png = parser.isSet(opt_png);
    bool ogg = parser.isSet(opt_ogg);
    bool midi = parser.isSet(opt_midi);
    bool all = parser.isSet(opt_all);
    bool sf2 = parser.isSet(opt_sf2);
    bool out = parser.isSet(opt_output);
    bool slow = parser.isSet(opt_slow);

    int lilypond_timeout = 5000;
    int timidity_timeout = 10000;

    // See issue #52
    if (slow)
    {
        lilypond_timeout *= 10;
        timidity_timeout *= 10;
    }

    const QStringList args = parser.positionalArguments();

    QApplication *guiApp = qobject_cast<QApplication *>(app.data());

    if (guiApp)
    {
        // Force light theme against default OS theme
        QPalette lightPalette;
        lightPalette.setColor(QPalette::Window, QColor(240, 240, 240));
        lightPalette.setColor(QPalette::WindowText, Qt::black);
        lightPalette.setColor(QPalette::Base, Qt::white);
        lightPalette.setColor(QPalette::AlternateBase, QColor(225, 225, 225));
        lightPalette.setColor(QPalette::ToolTipBase, Qt::white);
        lightPalette.setColor(QPalette::ToolTipText, Qt::black);
        lightPalette.setColor(QPalette::Text, Qt::black);
        lightPalette.setColor(QPalette::Button, QColor(240, 240, 240));
        lightPalette.setColor(QPalette::ButtonText, Qt::black);
        lightPalette.setColor(QPalette::BrightText, Qt::red);
        lightPalette.setColor(QPalette::Highlight, QColor(0, 120, 215));  // Light blue highlight
        lightPalette.setColor(QPalette::HighlightedText, Qt::white);

        guiApp->setStyle(QStyleFactory::create("Fusion"));
        guiApp->setPalette(lightPalette);

        // Check if a new version is available before to start the program
        try
        {
            QString res = FileDownloader::download("https://raw.githubusercontent.com/Jean-Romain/tabliato/master/version");
            QString ans = QString(res);
            QVersionNumber new_version = QVersionNumber::fromString(ans);
            QVersionNumber current_version = QVersionNumber::fromString(qApp->applicationVersion());
            QString fileName(LOCAL + "/no-update");
            QFile skip_update(fileName);

            QMessageBox msgBox;
            msgBox.setText("Une nouvelle version de tabliato est disponible");
            msgBox.setInformativeText(QString("Voulez vous installer tabliato " + new_version.toString()));
            msgBox.setIcon(QMessageBox::Question);
            msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No | QMessageBox::Ignore);
            msgBox.setDefaultButton(QMessageBox::Yes);
            msgBox.setButtonText(QMessageBox::Yes, "Oui");
            msgBox.setButtonText(QMessageBox::No, "Non");
            msgBox.setButtonText(QMessageBox::Ignore, "Plus tard");

            if (new_version > current_version)
            {
                // Si il n'y a pas de fichier c'est que l'utilisateur n'a jamais cliqué sur Non pour l'update
                // donc on demande s'il veut mettre à jour
                bool suggest_update = false;
                if (!skip_update.exists())
                {
                    suggest_update = true;
                }
                // Si le fichier existe c'est que l'utilisateur a dit non pour l'update
                // mais ca bloque pour l'éternité. Donc si c'est une version encore
                // plus grande que celle refusée par l'utilisateur on propose quand même
                else
                {
                    QVersionNumber skiped_version = QVersionNumber::fromString(File::read(fileName));
                    if (new_version > skiped_version)
                        suggest_update = true;
                }

                if (suggest_update)
                {
                    int ret = msgBox.exec();
                    if (ret == QMessageBox::Yes)
                    {
                        QDesktopServices::openUrl(QUrl("https://jean-romain.github.io/tabliato/download.html"));
                        skip_update.remove();
                        return 0;
                    }
                    else if (ret == QMessageBox::No)
                    {
                        File::write(fileName, new_version.toString());
                    }
                }
            }
        }
        catch (std::exception &e)
        {

        }

        // Start the program
        MainWindow fenetre;
        fenetre.show();

        if (args.size() >= 1)
            fenetre.open(args.at(0));

        return app->exec();
    }
    else
    {
        const QString rundir = QDir::currentPath();

        const QFileInfo input(args.at(0));
        const QString ifile = input.canonicalFilePath();
        const QString ifolder = input.canonicalPath();
        const QString iformat = input.suffix();

        const QFileInfo output(parser.value(opt_output));
        const QString ofile = out ? output.baseName() : input.baseName();
        const QString ofolder = out ? output.canonicalPath() : ifolder;

        const QString soundfont = sf2 ? parser.value(opt_sf2) : SOUNDFONTS + "/Loffet.sf2";

        // If it is a midi file move jump to audio conversion
        if (iformat == "midi" || iformat == "mid")
        {
            ogg = true;
            goto audio;
        }

        if (all)
        {
            pdf = true;
            ly = true;
            png = true;
            midi = true;
            ogg = true;
        }

        if (!pdf && !png)
        {
            pdf = true;
        }

        // ---------------------------------------
        // Parse tabliato code into lilypond code
        // ---------------------------------------

        {
            Tabulature tab = File::readdtb(ifile);

            try
            {
                TabliatoProcessor engine(tab);
            }
            catch(std::exception &e)
            {
                qCritical() << "Erreur:" << e.what();
                exit(1);
            }

            // ---------------------------------------
            // Call lilypond to create music sheet
            // ---------------------------------------

            QProcess lilypond;

            QFileInfo path(ifile);
            QString filebasepath = path.absolutePath() + "/" + path.baseName();

            QFile::remove(filebasepath + ".midi");
            QFile::remove(filebasepath + ".mid");
            QFile::remove(filebasepath + ".pdf");
            QFile::remove(filebasepath + ".png");
            QFile::remove(filebasepath + ".ogg");
            QFile::remove(filebasepath + ".wav");

            File::write(filebasepath + ".ly", tab.lilypond);

            if (!QFile(filebasepath + ".ly").exists())
            {
                QTextStream(stderr) << QString::fromUtf8("Erreur inconnue: le fichier lilypond n'a pas été produit.");
                return 1;
            }

            QStringList arguments;
            if (png) arguments.append("--png");
            if (pdf) arguments.append("--pdf");
            arguments.append(QString("--output=") + ofolder + "/" + ofile);
            arguments.append(filebasepath + ".ly");

            QString command = Lilypond::get_lilypond_command();

            lilypond.start(command, arguments);

            if (!lilypond.waitForStarted())
            {
                QTextStream(stderr) << QString::fromUtf8("Erreur inconnue: lilypond n'a pas été démarré.") << Qt::endl;
                return 1;
            }

            if (!lilypond.waitForFinished(lilypond_timeout))
            {
                lilypond.kill();
                lilypond.waitForFinished();
                QTextStream(stderr) << QString::fromUtf8("Temps maximum dépassé pour lilypond. La partition n'a pas été produite. Réessayer avec l'option 'Outils' > 'Configuration' > 'CPU faible performance'.") << Qt::endl;
                return 1;
            }

            // Check output files
            bool pdfExists = QFile(filebasepath + ".pdf").exists();
            bool pngExists = QFile(filebasepath + ".png").exists();

            if (!pdfExists && !pngExists)
            {
                QTextStream(stderr) << QString::fromUtf8("Erreur inconnue: le document n'a pas été compilé. Code probablement incorrect.") << Qt::endl;
                return 1;
            }

            if (!ly)
            {
                QFile::remove(filebasepath + ".ly");
            }

            if (!midi)
            {
                QFile::remove(filebasepath + ".mid");
                QFile::remove(filebasepath + ".midi");
            }
        }

        // ---------------------------------------
        // Call timidity to create audio file
        // ---------------------------------------

        audio:

        if (!ogg) return 0;

        QFile::remove(ofolder + "/" + ofile + AUDIOEXT);

        QProcess timidity;

        #ifdef Q_OS_WINDOWS
        QString command = APPDIR + "\\TiMidity++\\timidity.exe";
        QString mode = "-Ow";
        #endif

        #ifdef Q_OS_LINUX
        QString command = "timidity";
        QString mode = "-Ov";
        #endif

        QStringList arguments;
        arguments.append(ifile);
        arguments.append(mode);
        arguments.append("--config-string=soundfont\\ " + soundfont);
        arguments.append("--output-file=" + ofolder + "/" + ofile + AUDIOEXT);

        timidity.start(command, arguments);

        if (!timidity.waitForFinished(timidity_timeout))
        {
            timidity.kill();
            timidity.waitForFinished();
            QTextStream(stderr) << QString::fromUtf8("Erreur: temps maximum dépassé pour la conversion midi > audio. Le rendu audio n'a pas été produit. ´Réessayer avec l'option 'Outils' > 'Configuration' > 'CPU faible performance'.") << Qt::endl;
            return 1;
        }

        timidity.readAllStandardOutput();

        return 0;
    }
}
